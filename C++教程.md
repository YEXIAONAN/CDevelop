# 🧠 C++ 是什么？

C++ 是一种**静态类型**、**编译式**、**大小写敏感**的编程语言，支持多种编程范式，包括**过程式编程**、**面向对象编程**、**泛型编程**和**函数式编程**。

最初，C++ 被称为“带类的 C”（C with Classes），旨在扩展 C 语言的功能，引入面向对象的特性。 1983 年，它被正式命名为 C++，其中“++”象征着对 C 语言的增强。

C++ 是 C 的一个**超集**，事实上，任何合法的 C 程序都是合法的 C++ 程序。C++ 被认为是一种**中级语言**，它综合了高级语言和低级语言的特点。

> **注意**：使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。

---

## 🔍 核心特性

*   **多范式支持**：C++ 支持过程式、面向对象、泛型和函数式编程，使开发者可以根据需求选择最合适的编程风格。

*   **高性能**：C++ 提供对底层硬件的访问，允许精细的资源管理，适用于对性能要求高的应用，如游戏引擎、实时系统和高频交易平台。

*   **丰富的标准库**：C++ 拥有强大的标准库，包括标准模板库（STL），提供常用的数据结构和算法，简化开发过程。

*   **跨平台性**：C++ 程序可以在多个操作系统上编译和运行，包括 Windows、Linux 和 macOS，具有良好的可移植性。

---

## 🌐 C++ 应用领域

C++ 语言在许多行业和领域都有广泛应用，包括但不限于：

*   **系统软件**：操作系统、设备驱动程序等底层软件的开发。
*   **游戏开发**：C++ 是游戏开发领域中最常用的编程语言之一，因为它具有高效的性能和直接控制硬件的能力。许多主要的游戏引擎，如 Unreal Engine 和 Unity，都使用 C++ 编写。
*   **嵌入式系统开发**：C++ 可以在嵌入式系统中发挥重要作用，如智能手机、汽车、机器人和家电等领域。由于嵌入式系统通常具有严格的资源限制和实时要求，因此 C++ 的高效性能和内存控制功能非常有用。
*   **金融工程**：C++ 在金融领域中被广泛应用，如高频交易、算法交易和风险管理等领域。由于这些应用程序需要高效的性能和对硬件的直接控制，C++ 语言是一个合适的选择。
*   **图形图像处理**：C++ 可以用于开发图形和图像处理应用程序，如计算机视觉、计算机图形学和人工智能领域。由于这些应用程序需要高效的计算能力和对硬件的控制，因此 C++ 是一个很好的选择。
*   **科学计算和数值分析**：C++ 可以用于开发科学计算和数值分析应用程序，如数值模拟和高性能计算等领域。由于这些应用程序需要高效的计算能力和对硬件的直接控制，C++ 语言是一个很好的选择。

---

## 🧩 面向对象编程 (OOP)

C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：

*   **封装（Encapsulation）**：封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。这样可以提高安全性、可靠性和灵活性。
*   **继承（Inheritance）**：继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。这样可以提高代码的复用性和可扩展性。
*   **多态（Polymorphism）**：多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。它可以通过接口或继承实现，可以提高代码的灵活性和可读性。
*   **抽象（Abstraction）**：抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。抽象类和接口可以让程序员专注于高层次的设计和业务逻辑，而不必关注底层的实现细节。

---

## 📚 标准库

标准的 C++ 由三个重要部分组成：

*   **核心语言**：提供了所有构件块，包括变量、数据类型和常量，等等。
*   **C++ 标准库**：提供了大量的函数，用于操作文件、字符串等。
*   **标准模板库（STL）**：提供了大量的方法，用于操作数据结构等。

---

## 📜 ANSI 标准

ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。

由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。

---

## 💡 学习 C++ 的建议

学习 C++，关键是要理解概念，而不应过于深究语言的技术细节。

学习程序设计语言的目的是为了成为一个更好的程序员，也就是说，是为了能更有效率地设计和实现新系统，以及维护旧系统。

C++ 支持多种编程风格。您可以使用 Fortran、C、Smalltalk 等任意一种语言的编程风格来编写代码。每种风格都能有效地保证运行时间效率和空间效率。

---

## 📝 C++ 基本概念

C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象、方法和即时变量：

*   **对象（Object）**：对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种；行为 - 摇动、叫唤、吃。对象是类的实例。
*   **类（Class）**：类可以定义为描述对象行为/状态的模板/蓝图。
*   **方法（Method）**：从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。
*   **即时变量（Instance Variable）**：每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。

---

## 💻 C++ 程序结构与示例

让我们看一段简单的代码，可以输出单词 "Hello World"。

```cpp
#include <iostream> // 引入输入输出流库
using namespace std; // 使用标准命名空间
 
// main() 是程序开始执行的地方
int main()
{
   cout << "Hello World"; // 输出 Hello World
   return 0; // 终止 main() 函数并返回 0
}
```

接下来我们讲解一下上面这段程序：

*   `#include <iostream>`：C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 `<iostream>`，它提供了输入输出功能。
*   `using namespace std;`：告诉编译器使用 `std` 命名空间。命名空间是 C++ 中一个相对新的概念，用于避免名称冲突。
*   `// main() 是程序开始执行的地方`：这是一个单行注释。单行注释以 `//` 开头，在行末结束。
*   `int main()`：是主函数，程序从这里开始执行。
*   `cout << "Hello World";`：`cout` 是一个输出流对象，`<<` 是插入运算符，它会将字符串 `"Hello World"` 显示在屏幕上。
*   `return 0;`：终止 `main()` 函数，并向调用进程返回值 `0`。通常，`0` 表示程序成功执行。


---

# 💬 C++ 注释

程序的注释是**解释性语句**，您可以在 C++ 代码中包含，旨在**提高源代码的可读性**。几乎所有编程语言都支持某种形式的注释。

C++ 支持**单行注释**和**多行注释**两种形式。编译器在处理代码时会**忽略注释中的所有字符**。

---

## 📝 C++ 注释类型

C++ 注释一般有两种：

*   `//` - 一般用于单行注释。
*   `/* ... */` - 一般用于多行注释。

---

### 单行注释（`//`）

单行注释以 `//` 开头，其后的内容直到行末都被视为注释。

**示例 1：独立注释行**

```cpp
#include <iostream>
using namespace std;
 
int main() {
  // 这是一个注释
  cout << "Hello World!";
  return 0;
}
```

注释也可以放在语句的**同一行末尾**：

**示例 2：行尾注释**

```cpp
#include <iostream>
using namespace std;
 
int main()
{
   cout << "Hello World!"; // 输出 Hello World!
 
   return 0;
}
```

当上述代码被编译时，编译器会完全忽略注释内容，最终程序执行结果为：

```
Hello World!
```

---

### 多行注释（`/* ... */`）

多行注释以 `/*` 开始，并以 `*/` 终止。它可以跨越多行。

**示例：多行注释**

```cpp
#include <iostream>
using namespace std;
 
int main() {
    /* 这是注释 */
 
    /* C++ 注释也可以
     * 跨行
     */ 
    cout << "Hello World!";
    return 0;
}
```

---

### 注释的嵌套规则

*   在 `/* ... */` 类型的注释内部，`//` 不会被当作新的单行注释起始符，而是普通字符。
*   在 `//` 类型的注释内部，`/*` 和 `*/` 也只是普通字符，不会开始或结束多行注释。

这意味着**多行注释中可以包含单行注释**。

**重要提示**：标准 C++ 不支持多行注释（`/* ... */`）的**嵌套**。也就是说，在一个 `/*` 和 `*/` 之间，不能再出现另一个 `/*`...`*/` 结构，因为注释会在遇到第一个 `*/` 时就结束。

**示例：`//` 在 `/* ... */` 中**

```cpp
/* 用于输出 "Hello World" 的注释
 * 这是一个多行注释。
 * 它甚至可以包含单行注释：// 这是一段被忽略的文本
*/
cout << "Hello World"; // 这行代码在注释外面，会被编译
```
----


# 🧠 C++ 数据类型

在 C++ 编程中，理解数据类型是至关重要的。数据类型决定了变量的内存分配、可存储的值范围以及可执行的操作。

## 🔢 基本内置类型

C++ 提供了多种内置数据类型，主要包括：

* **布尔型** (`bool`)：表示真或假，取值为 `true` 或 `false`。
* **字符型** (`char`)：用于存储单个字符，通常为 ASCII 字符。
* **整型** (`int`)：用于存储整数。
* **浮点型** (`float`)：用于存储单精度浮点数。
* **双精度浮点型** (`double`)：用于存储双精度浮点数。
* **无类型** (`void`)：表示无类型，常用于函数返回类型。
* **宽字符型** (`wchar_t`)：用于存储宽字符，支持国际字符集。

## 🛠️ 类型修饰符

C++ 允许使用修饰符来改变基本数据类型的属性，以满足不同的编程需求：

* `signed`：表示有符号类型（默认）。
* `unsigned`：表示无符号类型。
* `short`：表示短整型。
* `long`：表示长整型。
* `const`：表示常量，值不可修改。
* `volatile`：表示变量可能被意外修改，禁止编译器优化。
* `mutable`：表示类成员可以在 `const` 对象中修改。

## 📊 数据类型大小与范围

不同数据类型在内存中占用的空间以及可表示的值范围如下（具体数值可能因系统和编译器而异）：

| 数据类型                 | 描述                          | 大小（字节）    | 范围/取值示例                                                |
| -------------------- | --------------------------- | --------- | ------------------------------------------------------ |
| `bool`               | 布尔类型，表示真或假                  | 1         | `true` 或 `false`                                       |
| `char`               | 字符类型，通常用于存储 ASCII 字符        | 1         | -128 到 127 或 0 到 255                                   |
| `signed char`        | 有符号字符类型                     | 1         | -128 到 127                                             |
| `unsigned char`      | 无符号字符类型                     | 1         | 0 到 255                                                |
| `wchar_t`            | 宽字符类型，用于存储 Unicode 字符       | 2 或 4     | 取决于平台                                                  |
| `char16_t`           | 16 位 Unicode 字符类型（C++11 引入） | 2         | 0 到 65,535                                             |
| `char32_t`           | 32 位 Unicode 字符类型（C++11 引入） | 4         | 0 到 4,294,967,295                                      |
| `short`              | 短整型                         | 2         | -32,768 到 32,767                                       |
| `unsigned short`     | 无符号短整型                      | 2         | 0 到 65,535                                             |
| `int`                | 整型                          | 4         | -2,147,483,648 到 2,147,483,647                         |
| `unsigned int`       | 无符号整型                       | 4         | 0 到 4,294,967,295                                      |
| `long`               | 长整型                         | 4 或 8     | 取决于平台                                                  |
| `unsigned long`      | 无符号长整型                      | 4 或 8     | 取决于平台                                                  |
| `long long`          | 长长整型（C++11 引入）              | 8         | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |
| `unsigned long long` | 无符号长长整型（C++11 引入）           | 8         | 0 到 18,446,744,073,709,551,615                         |
| `float`              | 单精度浮点数                      | 4         | 约 ±3.4e±38（6-7 位有效数字）                                  |
| `double`             | 双精度浮点数                      | 8         | 约 ±1.7e±308（15 位有效数字）                                  |
| `long double`        | 扩展精度浮点数                     | 8、12 或 16 | 取决于平台                                                  |

## 🆕 C++11 新增类型

C++11 引入了多种新类型，以增强语言的功能性和灵活性：

* `auto`：自动类型推断。
* `decltype`：获取表达式的类型。
* `nullptr`：空指针常量，替代传统的 `NULL`。
* `std::initializer_list`：初始化列表类型，支持列表初始化。
* `std::tuple`：元组类型，可以存储多个不同类型的值。

> 注意：各种类型的存储大小与系统位数有关，但目前通用的以 64 位系统为主。

---


### typedef声明
> 在C++中，你可以使用typedef为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：

```c
typedef type newname; 
```

- 例子:下面的语句会告诉编译器，zhengshu 是 int 的另一个名称：

```c
typedef int zhengshu;
```

当声明完成，你就可以使用"zhengshu"这个类型来创建新的变量
```c
zhengshu sum;
```

---


# 🔄 C++ 中的类型转换详解

在 C++ 编程中，类型转换是一个不可避免的过程。它允许我们将一种数据类型的值转换为另一种类型，以满足不同的编程需求。类型转换主要分为两大类：**隐式转换** 和 **显式转换（强制类型转换）**。

---

## 🤖 隐式类型转换（Implicit Conversion）

隐式转换是由编译器自动完成的类型转换，无需程序员干预。它通常发生在以下几种情况：

1. **赋值操作**：将一个类型的值赋给另一个兼容类型的变量时。

   ```cpp
   int i = 10;
   double d = i; // int 自动转换为 double
   ```
2. **表达式运算**：在混合类型的表达式中，较低精度的类型会被提升为较高精度的类型。

   ```cpp
   float f = 3.5f;
   double result = f + 2.0; // float 自动转换为 double
   ```
3. **函数调用**：函数参数类型与实参类型不同时，实参会被转换为形参类型。

   ```cpp
   void func(double d);
   func(5); // int 自动转换为 double
   ```

**注意事项**：

* 隐式转换可能导致数据精度丢失或溢出。例如，将 `double` 转换为 `int` 会丢失小数部分。
* 在涉及类类型时，编译器会尝试使用用户定义的转换函数或构造函数进行转换。

---

## 🛠️ 显式类型转换（Explicit Conversion）

显式转换，也称为强制类型转换，是由程序员明确指定的类型转换。C++ 提供了两种方式进行显式转换：

### 1. C 风格的强制类型转换

语法形式如下：

```cpp
type_name(expression);
```

或

```cpp
(type_name)expression;
```

例如：

```cpp
double d = 3.14;
int i = (int)d; // 将 double 强制转换为 int
```

**缺点**：

* 语义不明确，容易导致错误。
* 无法提供类型安全检查。

### 2. C++ 风格的强制类型转换

C++ 引入了四种新的强制类型转换操作符，以提供更强的类型安全和更清晰的语义：

#### 🔹 `static_cast`

用于相关类型之间的转换，如基本数据类型之间的转换，或类层次结构中向上或向下的转换。

**示例**：

```cpp
double d = 3.14;
int i = static_cast<int>(d); // 将 double 转换为 int
```

**特点**：

* 编译时类型检查，安全性较高。
* 不能移除 `const` 或 `volatile` 修饰符。

#### 🔹 `const_cast`

用于添加或移除 `const` 或 `volatile` 修饰符。

**示例**：

```cpp
const int* ptr = &value;
int* modifiable = const_cast<int*>(ptr); // 移除 const 修饰符
```

**注意**：

* 仅在确实需要修改 `const` 对象时使用，滥用可能导致未定义行为。

#### 🔹 `reinterpret_cast`

用于在完全不相关的类型之间进行低级别的转换，如指针类型之间的转换。

**示例**：

```cpp
int* p = new int(65);
char* ch = reinterpret_cast<char*>(p); // 将 int* 转换为 char*
```

**警告**：

* 非常危险，可能导致程序崩溃或数据损坏，除非确切知道自己在做什么，否则应避免使用。

#### 🔹 `dynamic_cast`

主要用于支持运行时类型识别（RTTI），用于类层次结构中安全地向下转换指针或引用。

**示例**：

```cpp
Base* basePtr = new Derived();
Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
```

**要求**：

* 基类必须至少有一个虚函数，以启用 RTTI。
* 如果转换失败，指针版本返回 `nullptr`，引用版本抛出 `std::bad_cast` 异常。

---

## 🧩 用户定义的类型转换

C++ 允许程序员定义自己的类型转换，以便在类之间或类与基本类型之间进行转换。主要有两种方式：

### 1. 转换构造函数

允许从其他类型构造当前类的对象。

**示例**：

```cpp
class MyClass {
public:
    MyClass(int value) { /* ... */ }
};
```

这使得可以通过以下方式进行转换：

```cpp
MyClass obj = 42; // int 被转换为 MyClass
```

### 2. 类型转换运算符

定义将当前类的对象转换为其他类型的运算符。

**示例**：

```cpp
class MyClass {
public:
    operator int() const { return /* ... */; }
};
```

这使得可以将 `MyClass` 对象转换为 `int` 类型。

---

## ⚠️ 类型转换的注意事项

* **数据丢失**：从高精度类型转换为低精度类型时，可能会丢失数据。
* **类型安全**：尽量使用 C++ 风格的强制类型转换，以提高类型安全性。
* **避免滥用**：避免不必要的类型转换，尤其是 `reinterpret_cast`，除非确切知道其后果。
* **RTTI 开销**：使用 `dynamic_cast` 需要启用 RTTI，可能会增加程序的开销。

---

